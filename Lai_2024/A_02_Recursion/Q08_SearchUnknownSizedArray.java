package A_02_Recursion;

abstract class Dictionary {
    public Integer get(int index) {
        return 0;
    }
}

public class Q08_SearchUnknownSizedArray {
    public int search(Dictionary dict, int target) {
        if (dict == null) {
            return -1;
        }

        // Step 1: Find the upper bound
        int left = 0;
        int right = 1;
        while (dict.get(right) != null && dict.get(right) < target) {
            left = right;
            right = right * 2;
        }

        // Step 2: Binary search
        while (left <= right) {
            int mid = left + (right - left) / 2;
            Integer value = dict.get(mid);

            if (value == null || value > target) {
                right = mid - 1;
            } else if (value < target) {
                left = mid + 1;
            } else {
                return mid;  // Found the target
            }
        }

        return -1;  // Target not found
    }
}

/**
让我们详细分析不同增长因子(growth factor)对性能的影响。假设目标值在位置 N。

        ### 1. 增长因子 = 2
        ```
序列: 1, 2, 4, 8, 16, 32, ...
        ```
分析:
        - 找到上界需要 log₂N 步
- 最终范围大小最多是 N
- 二分查找需要 log₂N 步
- 总查找次数 = log₂N + log₂N = 2log₂N

举例: N = 100
        - 探索序列: 1 → 2 → 4 → 8 → 16 → 32 → 64 → 128
        - 需要7步找到上界
- 二分查找范围: [64, 128]，需要约7步
- 总共约14步

### 2. 增长因子 = 1.5
        ```
序列: 1, 2, 3, 5, 8, 12, 18, 27, 41, 62, 93, 140, ...
        ```
分析:
        - 找到上界需要 log₁.₅N 步
- 最终范围更小，约 0.5N
- 二分查找需要 log₂N 步
- 总查找次数 = log₁.₅N + log₂N

举例: N = 100
        - 探索序列: 1 → 2 → 3 → 5 → 8 → 12 → 18 → 27 → 41 → 62 → 93 → 140
        - 需要11步找到上界
- 二分查找范围: [93, 140]，需要约6步
- 总共约17步

### 3. 增长因子 = 1.25
        ```
序列: 1, 2, 3, 4, 5, 7, 9, 12, 15, 19, 24, 30, 38, 48, 60, ...
        ```
分析:
 - 找到上界需要 log₁.₂₅N 步
- 最终范围最小，约 0.25N
- 二分查找需要 log₂N 步
- 总查找次数 = log₁.₂₅N + log₂N

举例: N = 100
        - 探索序列较长，需要更多步骤找到上界
- 二分查找范围更小，但前期探索成本高

### 性能对比表格

| 增长因子 | 找上界步数 | 最终范围 | 二分查找步数 | 总体效率 | 内存访问模式 |
        |---------|-----------|----------|------------|---------|------------|
        | 2.0     | 少        | 较大     | 较多       | 快      | 跳跃性大    |
        | 1.5     | 中等      | 中等     | 中等       | 中等    | 较平衡      |
        | 1.25    | 多        | 小       | 较少       | 慢      | 最均匀      |

        ### 不同场景的最佳选择

1. 内存访问昂贵的场景
- 最佳选择: 1.5 或 1.25
        - 原因: 更均匀的内存访问模式，减少缓存未命中

2. CPU计算为主的场景
- 最佳选择: 2.0
        - 原因: 需要的总步数最少

3. 数据分布稀疏的场景
- 最佳选择: 2.0 或更高
- 原因: 快速跳过空区间

4. 数据分布密集的场景
- 最佳选择: 1.5 或 1.25
        - 原因: 更精确的范围界定

### 结论

1. 增长因子 = 2.0
        - 优点: 计算步骤最少，实现简单
- 缺点: 可能会大幅超出目标范围

2. 增长因子 = 1.5
        - 优点: 平衡了查找步骤和范围精确度
- 缺点: 涉及浮点数计算

3. 增长因子 = 1.25
        - 优点: 范围最精确，内存访问最均匀
- 缺点: 需要更多的查找步骤

实际应用中，一般建议：
        - 默认使用增长因子 = 2.0
        - 如果内存访问成本高，考虑使用 1.5
        - 只在特殊场景下使用 1.25 或更小的增长因子
 */